from fastapi import FastAPI, Header, HTTPException, Depends, Query
from pydantic import BaseModel, Field
from typing import Optional, Any
from uuid import uuid4, UUID
from datetime import datetime, timezone, timedelta
import os
import json
import base64
import hmac
import hashlib
import secrets

import psycopg
from psycopg.errors import UniqueViolation


app = FastAPI(title="GlobApp API", version="1.0.0")

# -----------------------------
# Config helpers
# -----------------------------
def _get_env(name: str) -> str | None:
    v = os.getenv(name)
    if v is None:
        return None
    v = v.strip()
    return v if v else None


PUBLIC_KEY = _get_env("GLOBAPP_PUBLIC_API_KEY")
ADMIN_KEY = _get_env("GLOBAPP_ADMIN_API_KEY")
DB_URL = _get_env("DATABASE_URL")

JWT_SECRET = _get_env("GLOBAPP_JWT_SECRET") or ""
ACCESS_TOKEN_MINUTES = int(_get_env("GLOBAPP_ACCESS_TOKEN_MINUTES") or "15")
REFRESH_TOKEN_DAYS = int(_get_env("GLOBAPP_REFRESH_TOKEN_DAYS") or "30")

# Presence thresholds (seconds). Used by /dispatch/driver-presence and helper presence_status().
PRESENCE_ONLINE_SECONDS = int(_get_env("GLOBAPP_PRESENCE_ONLINE_SECONDS") or "60")   # <= 60s => online
PRESENCE_STALE_SECONDS = int(_get_env("GLOBAPP_PRESENCE_STALE_SECONDS") or "600")   # <= 10m => stale


def require_public_key(x_api_key: str | None):
    # If PUBLIC_KEY is not set, do not block (keeps backward compatibility)
    if not PUBLIC_KEY:
        return
    if x_api_key != PUBLIC_KEY:
        raise HTTPException(status_code=401, detail="Invalid API key")


def require_public_key_configured(x_api_key: str | None):
    """
    For endpoints that MUST be protected by the public/driver key.
    This avoids accidentally running location tracking with no key configured.
    """
    if not PUBLIC_KEY:
        raise HTTPException(status_code=500, detail="PUBLIC API key is not configured")
    if x_api_key != PUBLIC_KEY:
        raise HTTPException(status_code=401, detail="Invalid API key")


def require_admin_key(x_api_key: str | None):
    # Admin endpoints should be protected once ADMIN_KEY is set
    if not ADMIN_KEY:
        raise HTTPException(status_code=500, detail="ADMIN API key is not configured")
    if x_api_key != ADMIN_KEY:
        raise HTTPException(status_code=401, detail="Invalid API key")


def db_conn():
    if not DB_URL:
        raise HTTPException(status_code=500, detail="DATABASE_URL is not configured")
    return psycopg.connect(DB_URL)


# -----------------------------
# Phone normalization + masking
# -----------------------------
def normalize_phone(raw: str, default_country_code: str = "1") -> str:
    """
    Normalize phone into a predictable, unique format.

    Output format: +<countrycode><digits>
    For now, we assume US default if no country code is provided.

    Examples:
      "5550009999"           -> "+15550009999"
      "(555) 000-9999"       -> "+15550009999"
      "+1 555 000 9999"      -> "+15550009999"
      "1-555-000-9999"       -> "+15550009999"

    Raises 400 if input is not plausible.
    """
    if not raw or not raw.strip():
        raise HTTPException(status_code=400, detail="phone is required")

    digits = "".join(ch for ch in raw if ch.isdigit())

    # US-style rules (simple and predictable):
    # - 10 digits => assume US country code 1
    # - 11 digits starting with 1 => treat as US country code 1
    if len(digits) == 10:
        digits = default_country_code + digits
    elif len(digits) == 11 and digits.startswith(default_country_code):
        pass
    else:
        raise HTTPException(
            status_code=400,
            detail="phone must be 10 digits (US) or 11 digits starting with country code 1",
        )

    return f"+{digits}"


def mask_phone(phone: str) -> str:
    # minimal masking: keep last 4
    if not phone:
        return phone
    digits = "".join([c for c in phone if c.isdigit()])
    if len(digits) < 4:
        return "***"
    return f"***{digits[-4:]}"


# -----------------------------
# Presence helper
# -----------------------------
def presence_status(age_seconds: float | None) -> str:
    """
    age_seconds:
      - None => no ping on record => offline
      - <= ONLINE => online
      - <= STALE  => stale
      - else      => offline
    """
    if age_seconds is None:
        return "offline"
    if age_seconds <= PRESENCE_ONLINE_SECONDS:
        return "online"
    if age_seconds <= PRESENCE_STALE_SECONDS:
        return "stale"
    return "offline"


# -----------------------------
# PIN hashing (no external deps)
# -----------------------------
def _hash_pin(pin: str, salt: str) -> str:
    # PBKDF2-HMAC-SHA256
    dk = hashlib.pbkdf2_hmac(
        "sha256",
        pin.encode("utf-8"),
        salt.encode("utf-8"),
        200_000,
        dklen=32,
    )
    return base64.urlsafe_b64encode(dk).decode("utf-8").rstrip("=")


def set_driver_pin(pin: str) -> tuple[str, str]:
    salt = secrets.token_urlsafe(16)
    pin_hash = _hash_pin(pin, salt)
    return salt, pin_hash


def verify_driver_pin(pin: str, salt: str, pin_hash: str) -> bool:
    check = _hash_pin(pin, salt)
    return hmac.compare_digest(check, pin_hash)


# -----------------------------
# Minimal JWT (HS256) implementation
# -----------------------------
def _b64url_encode(raw: bytes) -> str:
    return base64.urlsafe_b64encode(raw).decode("utf-8").rstrip("=")


def _b64url_decode(s: str) -> bytes:
    pad = "=" * (-len(s) % 4)
    return base64.urlsafe_b64decode((s + pad).encode("utf-8"))


def jwt_encode(payload: dict, secret: str) -> str:
    header = {"alg": "HS256", "typ": "JWT"}
    header_b64 = _b64url_encode(json.dumps(header, separators=(",", ":")).encode("utf-8"))
    payload_b64 = _b64url_encode(json.dumps(payload, separators=(",", ":")).encode("utf-8"))
    msg = f"{header_b64}.{payload_b64}".encode("utf-8")
    sig = hmac.new(secret.encode("utf-8"), msg, hashlib.sha256).digest()
    sig_b64 = _b64url_encode(sig)
    return f"{header_b64}.{payload_b64}.{sig_b64}"


def jwt_decode(token: str, secret: str) -> dict:
    try:
        header_b64, payload_b64, sig_b64 = token.split(".")
    except ValueError:
        raise HTTPException(status_code=401, detail="Invalid token format")

    msg = f"{header_b64}.{payload_b64}".encode("utf-8")
    expected_sig = hmac.new(secret.encode("utf-8"), msg, hashlib.sha256).digest()
    actual_sig = _b64url_decode(sig_b64)

    if not hmac.compare_digest(expected_sig, actual_sig):
        raise HTTPException(status_code=401, detail="Invalid token signature")

    payload = json.loads(_b64url_decode(payload_b64).decode("utf-8"))

    exp = payload.get("exp")
    if exp is not None:
        now_ts = int(datetime.now(timezone.utc).timestamp())
        if now_ts > int(exp):
            raise HTTPException(status_code=401, detail="Token expired")

    return payload


def require_jwt_secret():
    if not JWT_SECRET:
        raise HTTPException(status_code=500, detail="JWT secret is not configured (GLOBAPP_JWT_SECRET)")


def make_access_token(driver_id: UUID) -> str:
    require_jwt_secret()
    now = datetime.now(timezone.utc)
    exp = now + timedelta(minutes=ACCESS_TOKEN_MINUTES)
    payload = {
        "sub": str(driver_id),
        "iat": int(now.timestamp()),
        "exp": int(exp.timestamp()),
        "typ": "access",
    }
    return jwt_encode(payload, JWT_SECRET)


def hash_refresh_token(raw_token: str) -> str:
    # store only hash in DB
    h = hashlib.sha256(raw_token.encode("utf-8")).digest()
    return _b64url_encode(h)


def make_refresh_token() -> str:
    # random long token, not a JWT
    return secrets.token_urlsafe(48)


def get_bearer_token(authorization: str | None = Header(default=None, alias="Authorization")) -> str:
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing Authorization header")
    parts = authorization.split(" ", 1)
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(status_code=401, detail="Invalid Authorization header")
    return parts[1].strip()


def require_driver_access_token(token: str = Depends(get_bearer_token)) -> UUID:
    require_jwt_secret()
    payload = jwt_decode(token, JWT_SECRET)
    if payload.get("typ") != "access":
        raise HTTPException(status_code=401, detail="Invalid token type")
    sub = payload.get("sub")
    if not sub:
        raise HTTPException(status_code=401, detail="Missing subject")
    try:
        return UUID(sub)
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid subject")


# -----------------------------
# Models
# -----------------------------
class RideQuoteIn(BaseModel):
    pickup: str
    dropoff: str
    service_type: str = "economy"


class RideCreateIn(BaseModel):
    rider_name: str
    rider_phone: str
    pickup: str
    dropoff: str
    service_type: str = "economy"


class DriverCreateIn(BaseModel):
    name: str
    phone: str
    vehicle: Optional[str] = None
    is_active: bool = True
    pin: Optional[str] = None


class DriverLoginIn(BaseModel):
    phone: str
    pin: str
    device_id: Optional[str] = None


class DriverRefreshIn(BaseModel):
    refresh_token: str
    device_id: Optional[str] = None


class DriverLocationUpsert(BaseModel):
    lat: float = Field(..., ge=-90, le=90)
    lng: float = Field(..., ge=-180, le=180)
    heading_deg: float | None = Field(default=None, ge=0, le=360)
    speed_mph: float | None = Field(default=None, ge=0)
    accuracy_m: float | None = Field(default=None, ge=0)


class RideAssignIn(BaseModel):
    driver_id: UUID


class RideStatusUpdateIn(BaseModel):
    status: str


# -----------------------------
# Existing (keep)
# -----------------------------
@app.get("/api/")
def api_root():
    return {"status": "ok", "service": "globapp", "message": "Real backend is live."}


@app.get("/api/health")
def health():
    return {"ok": True}


# -----------------------------
# v1 (stable contract)
# -----------------------------
@app.get("/api/v1/health")
def v1_health():
    return {"ok": True, "version": "v1", "environment": os.getenv("APP_ENV", "unknown")}


@app.get("/api/v1/info")
def v1_info():
    return {
        "service": "globapp",
        "api_version": "v1",
        "app_version": app.version,
        "environment": os.getenv("APP_ENV", "unknown"),
    }


@app.get("/api/v1/time")
def v1_time():
    return {"utc": datetime.now(timezone.utc).isoformat()}


# -----------------------------
# Rides (PUBLIC key)
# NOTE: expects rides table has rider_phone_raw and rider_phone_e164 columns.
# -----------------------------
@app.post("/api/v1/rides/quote")
def rides_quote(payload: RideQuoteIn, x_api_key: str | None = Header(default=None, alias="X-API-Key")):
    require_public_key(x_api_key)

    estimated_distance_miles = 2.6
    estimated_duration_min = 8
    base = 4.00
    per_mile = 1.00
    price = round(base + per_mile * estimated_distance_miles, 2)

    return {
        "service_type": payload.service_type,
        "estimated_distance_miles": estimated_distance_miles,
        "estimated_duration_min": estimated_duration_min,
        "estimated_price_usd": price,
    }


@app.post("/api/v1/rides")
def create_ride(payload: RideCreateIn, x_api_key: str | None = Header(default=None, alias="X-API-Key")):
    require_public_key(x_api_key)

    estimated_distance_miles = 2.6
    estimated_duration_min = 8
    base = 4.00
    per_mile = 1.00
    estimated_price_usd = round(base + per_mile * estimated_distance_miles, 2)

    ride_id = uuid4()
    created_at_utc = datetime.now(timezone.utc).replace(tzinfo=None)

    rider_phone_raw = (payload.rider_phone or "").strip()
    rider_phone_e164 = normalize_phone(rider_phone_raw)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO rides (
                        id, rider_name, rider_phone_raw, rider_phone_e164, pickup, dropoff, service_type,
                        estimated_distance_miles, estimated_duration_min, estimated_price_usd,
                        status, created_at_utc
                    )
                    VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)
                    """,
                    (
                        str(ride_id),
                        payload.rider_name,
                        rider_phone_raw,
                        rider_phone_e164,
                        payload.pickup,
                        payload.dropoff,
                        payload.service_type,
                        float(estimated_distance_miles),
                        float(estimated_duration_min),
                        float(estimated_price_usd),
                        "requested",
                        created_at_utc,
                    ),
                )
                conn.commit()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB insert failed: {e}")

    return {
        "ride_id": str(ride_id),
        "status": "requested",
        "created_at_utc": created_at_utc.isoformat(),
        "rider_phone_masked": mask_phone(rider_phone_e164),
    }


# -----------------------------
# Drivers (ADMIN key)
# -----------------------------
@app.get("/api/v1/drivers")
def list_drivers(x_api_key: str | None = Header(default=None, alias="X-API-Key")):
    require_admin_key(x_api_key)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT id, name, phone, vehicle, is_active, created_at_utc
                    FROM drivers
                    ORDER BY created_at_utc DESC
                    LIMIT 200
                    """
                )
                rows = cur.fetchall()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    return [
        {
            "id": str(r[0]),
            "name": r[1],
            "phone": r[2],
            "masked_phone": mask_phone(r[2]),
            "vehicle": r[3],
            "is_active": r[4],
            "created_at_utc": r[5].isoformat() if r[5] else None,
        }
        for r in rows
    ]


@app.post("/api/v1/drivers")
def create_driver(payload: DriverCreateIn, x_api_key: str | None = Header(default=None, alias="X-API-Key")):
    require_admin_key(x_api_key)

    driver_id = uuid4()
    created_at_utc = datetime.now(timezone.utc).replace(tzinfo=None)
    phone_norm = normalize_phone(payload.phone)

    pin_salt = None
    pin_hash = None
    if payload.pin:
        pin_salt, pin_hash = set_driver_pin(payload.pin)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO drivers (id, name, phone, vehicle, is_active, created_at_utc, pin_salt, pin_hash)
                    VALUES (%s,%s,%s,%s,%s,%s,%s,%s)
                    """,
                    (
                        str(driver_id),
                        payload.name,
                        phone_norm,
                        payload.vehicle,
                        payload.is_active,
                        created_at_utc,
                        pin_salt,
                        pin_hash,
                    ),
                )
                conn.commit()
    except UniqueViolation:
        raise HTTPException(status_code=409, detail="Driver with this phone already exists")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB insert failed: {e}")

    return {
        "id": str(driver_id),
        "status": "created",
        "created_at_utc": created_at_utc.isoformat(),
        "masked_phone": mask_phone(phone_norm),
        "pin_set": True if payload.pin else False,
    }


# -----------------------------
# Driver auth
# -----------------------------
@app.post("/api/v1/driver/login")
def driver_login(payload: DriverLoginIn):
    phone_norm = normalize_phone(payload.phone)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT id, pin_salt, pin_hash, is_active
                    FROM drivers
                    WHERE phone = %s
                    LIMIT 1
                    """,
                    (phone_norm,),
                )
                row = cur.fetchone()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    if not row:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    driver_id = UUID(str(row[0]))
    pin_salt = row[1]
    pin_hash = row[2]
    is_active = row[3]

    if not is_active:
        raise HTTPException(status_code=403, detail="Driver is inactive")
    if not pin_salt or not pin_hash:
        raise HTTPException(status_code=403, detail="Driver PIN is not set")
    if not verify_driver_pin(payload.pin, pin_salt, pin_hash):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    access_token = make_access_token(driver_id)

    refresh_token = make_refresh_token()
    refresh_hash = hash_refresh_token(refresh_token)
    expires_at_utc = (datetime.now(timezone.utc) + timedelta(days=REFRESH_TOKEN_DAYS)).replace(tzinfo=None)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO driver_refresh_tokens (id, driver_id, token_hash, device_id, expires_at_utc)
                    VALUES (%s, %s, %s, %s, %s)
                    """,
                    (str(uuid4()), str(driver_id), refresh_hash, payload.device_id, expires_at_utc),
                )
                conn.commit()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB insert failed: {e}")

    return {
        "driver_id": str(driver_id),
        "access_token": access_token,
        "access_token_expires_minutes": ACCESS_TOKEN_MINUTES,
        "refresh_token": refresh_token,
        "refresh_token_expires_days": REFRESH_TOKEN_DAYS,
    }


@app.post("/api/v1/driver/refresh")
def driver_refresh(payload: DriverRefreshIn):
    refresh_hash = hash_refresh_token(payload.refresh_token)
    now_utc = datetime.now(timezone.utc)
    now_naive = now_utc.replace(tzinfo=None)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT id, driver_id, expires_at_utc, revoked_at_utc
                    FROM driver_refresh_tokens
                    WHERE token_hash = %s
                    LIMIT 1
                    """,
                    (refresh_hash,),
                )
                row = cur.fetchone()

                if not row:
                    raise HTTPException(status_code=401, detail="Invalid refresh token")

                token_row_id = row[0]
                driver_id = UUID(str(row[1]))
                expires_at_utc = row[2]
                revoked_at_utc = row[3]

                if revoked_at_utc is not None:
                    raise HTTPException(status_code=401, detail="Refresh token revoked")
                if expires_at_utc and expires_at_utc < now_naive:
                    raise HTTPException(status_code=401, detail="Refresh token expired")

                # Revoke old token
                cur.execute(
                    """
                    UPDATE driver_refresh_tokens
                    SET revoked_at_utc = %s
                    WHERE id = %s
                    """,
                    (now_naive, token_row_id),
                )

                # Issue new refresh token
                new_refresh = make_refresh_token()
                new_hash = hash_refresh_token(new_refresh)
                new_expires_at = (now_utc + timedelta(days=REFRESH_TOKEN_DAYS)).replace(tzinfo=None)

                cur.execute(
                    """
                    INSERT INTO driver_refresh_tokens (id, driver_id, token_hash, device_id, expires_at_utc)
                    VALUES (%s, %s, %s, %s, %s)
                    """,
                    (str(uuid4()), str(driver_id), new_hash, payload.device_id, new_expires_at),
                )

                conn.commit()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB operation failed: {e}")

    access_token = make_access_token(driver_id)

    return {
        "driver_id": str(driver_id),
        "access_token": access_token,
        "access_token_expires_minutes": ACCESS_TOKEN_MINUTES,
        "refresh_token": new_refresh,
        "refresh_token_expires_days": REFRESH_TOKEN_DAYS,
    }


# =========================================================
# Phase 2 — Step 1: Driver location tracking
# =========================================================
@app.put("/api/v1/driver/location")
def upsert_my_location(
    payload: DriverLocationUpsert,
    driver_id: UUID = Depends(require_driver_access_token),
):
    updated_at_utc = datetime.now(timezone.utc).replace(tzinfo=None)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO driver_locations (driver_id, lat, lng, heading_deg, speed_mph, accuracy_m, updated_at_utc)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    ON CONFLICT (driver_id) DO UPDATE SET
                      lat = EXCLUDED.lat,
                      lng = EXCLUDED.lng,
                      heading_deg = EXCLUDED.heading_deg,
                      speed_mph = EXCLUDED.speed_mph,
                      accuracy_m = EXCLUDED.accuracy_m,
                      updated_at_utc = EXCLUDED.updated_at_utc
                    """,
                    (
                        str(driver_id),
                        payload.lat,
                        payload.lng,
                        payload.heading_deg,
                        payload.speed_mph,
                        payload.accuracy_m,
                        updated_at_utc,
                    ),
                )
                conn.commit()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB upsert failed: {e}")

    return {"ok": True, "driver_id": str(driver_id), "updated_at_utc": updated_at_utc.isoformat()}


@app.get("/api/v1/drivers/{driver_id}/location")
def get_driver_location(
    driver_id: UUID,
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
):
    require_admin_key(x_api_key)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT driver_id, lat, lng, heading_deg, speed_mph, accuracy_m, updated_at_utc
                    FROM driver_locations
                    WHERE driver_id = %s
                    """,
                    (str(driver_id),),
                )
                row = cur.fetchone()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    if not row:
        return None

    return {
        "driver_id": str(row[0]),
        "lat": row[1],
        "lng": row[2],
        "heading_deg": row[3],
        "speed_mph": row[4],
        "accuracy_m": row[5],
        "updated_at_utc": row[6].isoformat() if row[6] else None,
    }


@app.get("/api/v1/dispatch/available-drivers")
def list_available_drivers(
    minutes_recent: int = 5,
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
):
    require_admin_key(x_api_key)

    if minutes_recent < 1:
        raise HTTPException(status_code=400, detail="minutes_recent must be >= 1")

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT d.id, d.name, d.phone, d.vehicle, d.is_active,
                           dl.lat, dl.lng, dl.updated_at_utc
                    FROM drivers d
                    JOIN driver_locations dl ON dl.driver_id = d.id
                    WHERE d.is_active = true
                      AND dl.updated_at_utc >= (now() - (%s || ' minutes')::interval)
                    ORDER BY dl.updated_at_utc DESC
                    """,
                    (minutes_recent,),
                )
                rows = cur.fetchall()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB query failed: {e}")

    return [
        {
            "driver_id": str(r[0]),
            "name": r[1],
            "phone": r[2],
            "masked_phone": mask_phone(r[2]),
            "vehicle": r[3],
            "lat": r[5],
            "lng": r[6],
            "last_seen_utc": r[7].isoformat() if r[7] else None,
        }
        for r in rows
    ]


@app.get("/api/v1/dispatch/driver-presence")
def driver_presence(
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
):
    require_admin_key(x_api_key)

    now = datetime.now(timezone.utc)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT
                        d.id, d.name, d.phone, d.vehicle, d.is_active,
                        dl.lat, dl.lng, dl.updated_at_utc
                    FROM drivers d
                    LEFT JOIN driver_locations dl ON dl.driver_id = d.id
                    ORDER BY d.created_at_utc DESC
                    LIMIT 500
                    """
                )
                rows = cur.fetchall()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB query failed: {e}")

    out = []
    for r in rows:
        driver_id = str(r[0])
        name = r[1]
        phone = r[2]
        vehicle = r[3]
        is_active = r[4]
        lat = r[5]
        lng = r[6]
        last_seen = r[7]  # may be None (naive UTC stored)

        age_seconds = None
        if last_seen is not None:
            last_seen_utc = last_seen.replace(tzinfo=timezone.utc)
            age_seconds = (now - last_seen_utc).total_seconds()

        out.append(
            {
                "driver_id": driver_id,
                "name": name,
                "phone": phone,
                "vehicle": vehicle,
                "is_active": bool(is_active),
                "status": presence_status(age_seconds),
                "lat": lat,
                "lng": lng,
                "last_seen_utc": last_seen.isoformat() if last_seen else None,
                "age_seconds": age_seconds,
            }
        )

    return out


# =========================================================
# Phase 2 — Step 2: Dispatch assigns rides + driver fetches assignment
# =========================================================
@app.get("/api/v1/dispatch/rides")
def dispatch_list_rides(
    status: str = "requested",
    limit: int = 50,
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
):
    require_admin_key(x_api_key)

    if limit < 1 or limit > 200:
        raise HTTPException(status_code=400, detail="limit must be between 1 and 200")

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT
                        id, rider_name, rider_phone_raw, rider_phone_e164, pickup, dropoff, service_type,
                        status, created_at_utc,
                        assigned_driver_id, assigned_at_utc
                    FROM rides
                    WHERE status = %s
                    ORDER BY created_at_utc DESC
                    LIMIT %s
                    """,
                    (status, limit),
                )
                rows = cur.fetchall()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    return [
        {
            "ride_id": str(r[0]),
            "rider_name": r[1],
            "rider_phone_raw": r[2],
            "rider_phone_e164": r[3],
            "pickup": r[4],
            "dropoff": r[5],
            "service_type": r[6],
            "status": r[7],
            "created_at_utc": r[8].isoformat() if r[8] else None,
            "assigned_driver_id": str(r[9]) if r[9] else None,
            "assigned_at_utc": r[10].isoformat() if r[10] else None,
        }
        for r in rows
    ]


@app.post("/api/v1/dispatch/rides/{ride_id}/assign")
def dispatch_assign_ride(
    ride_id: UUID,
    payload: RideAssignIn,
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
):
    require_admin_key(x_api_key)

    now_utc = datetime.now(timezone.utc).replace(tzinfo=None)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT status
                    FROM rides
                    WHERE id = %s
                    """,
                    (str(ride_id),),
                )
                ride = cur.fetchone()
                if not ride:
                    raise HTTPException(status_code=404, detail="Ride not found")

                status = ride[0]
                if status not in ("requested", "assigned"):
                    raise HTTPException(status_code=400, detail=f"Ride is not assignable (status={status})")

                cur.execute(
                    """
                    SELECT is_active
                    FROM drivers
                    WHERE id = %s
                    """,
                    (str(payload.driver_id),),
                )
                drow = cur.fetchone()
                if not drow:
                    raise HTTPException(status_code=404, detail="Driver not found")
                if not drow[0]:
                    raise HTTPException(status_code=403, detail="Driver is inactive")

                cur.execute(
                    """
                    UPDATE rides
                    SET assigned_driver_id = %s,
                        assigned_at_utc = %s,
                        status = 'assigned'
                    WHERE id = %s
                    """,
                    (str(payload.driver_id), now_utc, str(ride_id)),
                )

                conn.commit()

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB operation failed: {e}")

    return {
        "ok": True,
        "ride_id": str(ride_id),
        "assigned_driver_id": str(payload.driver_id),
        "assigned_at_utc": now_utc.isoformat(),
        "status": "assigned",
    }


@app.get("/api/v1/driver/assigned-ride")
def driver_assigned_ride(
    driver_id: UUID = Depends(require_driver_access_token),
):
    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT
                        id, rider_name, rider_phone_raw, rider_phone_e164, pickup, dropoff, service_type,
                        status, created_at_utc, assigned_at_utc
                    FROM rides
                    WHERE assigned_driver_id = %s
                      AND status IN ('assigned','enroute','arrived','in_progress')
                    ORDER BY assigned_at_utc DESC NULLS LAST
                    LIMIT 1
                    """,
                    (str(driver_id),),
                )
                row = cur.fetchone()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    if not row:
        return None

    # Driver sees masked rider phone (minimal best practice)
    rider_phone_e164 = row[3]

    return {
        "ride_id": str(row[0]),
        "rider_name": row[1],
        "rider_phone_masked": mask_phone(rider_phone_e164) if rider_phone_e164 else None,
        "pickup": row[4],
        "dropoff": row[5],
        "service_type": row[6],
        "status": row[7],
        "created_at_utc": row[8].isoformat() if row[8] else None,
        "assigned_at_utc": row[9].isoformat() if row[9] else None,
    }


# =========================================================
# Phase 2 — Step 3: Driver updates ride status
# =========================================================
_ALLOWED_STATUSES = {"assigned", "enroute", "arrived", "in_progress", "completed", "cancelled"}
_STATUS_ORDER = {
    "assigned": 1,
    "enroute": 2,
    "arrived": 3,
    "in_progress": 4,
    "completed": 5,
    "cancelled": 99,  # special terminal
}


@app.post("/api/v1/driver/rides/{ride_id}/status")
def driver_update_ride_status(
    ride_id: UUID,
    payload: RideStatusUpdateIn,
    driver_id: UUID = Depends(require_driver_access_token),
):
    new_status = (payload.status or "").strip().lower()
    if new_status not in _ALLOWED_STATUSES:
        raise HTTPException(status_code=400, detail=f"Invalid status. Allowed: {sorted(_ALLOWED_STATUSES)}")

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT assigned_driver_id, status
                    FROM rides
                    WHERE id = %s
                    """,
                    (str(ride_id),),
                )
                row = cur.fetchone()
                if not row:
                    raise HTTPException(status_code=404, detail="Ride not found")

                assigned_driver_id = row[0]
                current_status = row[1]

                if not assigned_driver_id:
                    raise HTTPException(status_code=400, detail="Ride is not assigned to any driver")
                if str(assigned_driver_id) != str(driver_id):
                    raise HTTPException(status_code=403, detail="Ride is not assigned to this driver")

                if not current_status:
                    current_status = "requested"
                current_status_norm = str(current_status).strip().lower()

                if current_status_norm in ("completed", "cancelled"):
                    raise HTTPException(status_code=400, detail=f"Ride is already terminal (status={current_status_norm})")

                if new_status != "cancelled":
                    if current_status_norm not in _STATUS_ORDER:
                        raise HTTPException(status_code=400, detail=f"Cannot transition from status={current_status_norm}")
                    if _STATUS_ORDER[new_status] < _STATUS_ORDER[current_status_norm]:
                        raise HTTPException(
                            status_code=400,
                            detail=f"Invalid status regression: {current_status_norm} -> {new_status}",
                        )

                cur.execute(
                    """
                    UPDATE rides
                    SET status = %s
                    WHERE id = %s
                    """,
                    (new_status, str(ride_id)),
                )
                conn.commit()

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB operation failed: {e}")

    return {"ok": True, "ride_id": str(ride_id), "driver_id": str(driver_id), "status": new_status}


# =========================================================
# Phase 2 — Step 4 (NEW): Driver ride history + Dispatch ride detail
# =========================================================

@app.get("/api/v1/driver/rides")
def driver_list_my_rides(
    limit: int = Query(default=50, ge=1, le=200),
    driver_id: UUID = Depends(require_driver_access_token),
):
    """
    Driver lists their own rides (history).

    Minimal best practice:
      - driver can only see rides assigned to them
      - rider phone returned as masked only (no raw/e164 exposure)
    """
    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT
                        id, rider_name, rider_phone_e164, pickup, dropoff, service_type,
                        status, created_at_utc, assigned_at_utc
                    FROM rides
                    WHERE assigned_driver_id = %s
                    ORDER BY created_at_utc DESC
                    LIMIT %s
                    """,
                    (str(driver_id), limit),
                )
                rows = cur.fetchall()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    return [
        {
            "ride_id": str(r[0]),
            "rider_name": r[1],
            "rider_phone_masked": mask_phone(r[2]) if r[2] else None,
            "pickup": r[3],
            "dropoff": r[4],
            "service_type": r[5],
            "status": r[6],
            "created_at_utc": r[7].isoformat() if r[7] else None,
            "assigned_at_utc": r[8].isoformat() if r[8] else None,
        }
        for r in rows
    ]


@app.get("/api/v1/dispatch/rides/{ride_id}")
def dispatch_get_ride_detail(
    ride_id: UUID,
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
):
    """
    Dispatch/Admin ride detail view.

    Best practice:
      - this is ADMIN only
      - admin can see rider_phone_raw and rider_phone_e164 for support workflows
    """
    require_admin_key(x_api_key)

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    SELECT
                        id,
                        rider_name,
                        rider_phone_raw,
                        rider_phone_e164,
                        pickup,
                        dropoff,
                        service_type,
                        estimated_distance_miles,
                        estimated_duration_min,
                        estimated_price_usd,
                        status,
                        created_at_utc,
                        assigned_driver_id,
                        assigned_at_utc
                    FROM rides
                    WHERE id = %s
                    LIMIT 1
                    """,
                    (str(ride_id),),
                )
                r = cur.fetchone()
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB read failed: {e}")

    if not r:
        raise HTTPException(status_code=404, detail="Ride not found")

    return {
        "ride_id": str(r[0]),
        "rider_name": r[1],
        "rider_phone_raw": r[2],
        "rider_phone_e164": r[3],
        "rider_phone_masked": mask_phone(r[3]) if r[3] else None,
        "pickup": r[4],
        "dropoff": r[5],
        "service_type": r[6],
        "estimated_distance_miles": r[7],
        "estimated_duration_min": r[8],
        "estimated_price_usd": r[9],
        "status": r[10],
        "created_at_utc": r[11].isoformat() if r[11] else None,
        "assigned_driver_id": str(r[12]) if r[12] else None,
        "assigned_at_utc": r[13].isoformat() if r[13] else None,
    }
